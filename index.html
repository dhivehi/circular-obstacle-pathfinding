<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" media="screen" href="style.css"/>
    <title>Circular Obstacle Pathfinding</title>
    <meta name="description" content="Pathfinding around a set of circular obstacles"/>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>    
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/redblobgames/circular-obstacle-pathfinding">View on GitHub</a>
    <header>
      <div>
        <h1>Circular Obstacle Pathfinding</h1>
        <h2>Pathfinding around a set of circular obstacles</h2>
      </div>
    </header>

    <section id="main_content">
      <div>
        
        <address>Mar 2017</address>

        <h2 id="navigating-a-forest">Navigating a forest</h2>

        <p>
          The A* pathfinding algorithm is a powerful method for quickly
          generating optimal paths. Typically, people demonstrate A* navigating
          grid-based maps such as this one, avoiding obstacles to reach a goal.
        </p>

        <p>
          [Diagram here]
        </p>

        <p>
          But A* isn’t just a grid algorithm! It can work on any graph. We can
          use A* to find a path for this round object through this world of
          round obstacles.
        </p>

        <p>
          [Diagram here, with lots of obstacles, draggable start/endpoints, slider
          for actor radius]
        </p>

        <p>
          How does the same algorithm solve both problems?
        </p>

        <h3 id="first-steps">First steps</h3>

        <p>
          When navigating a round object through a world of round obstacles, we
          can make a few observations that simplify the problem. First, we can
          make things easier by noticing that moving a circle of radius <em>r</em>
          through a forest of round obstacles is identical to moving a point
          through that same forest with one change: each obstacle has its radius
          increased by <em>r</em>. This is an extremely simple application of
          <em>Minkowski addition</em>, and it’s so effective for this case that from
          now on we’ll ignore the radius of the moving object. If it has a
          radius larger than zero, we’ll just increase the size of the obstacles
          before we start.
        </p>

        <p>
          Another observation to make about the problem is that the paths
          consist of two types of sections: line segments and circular arcs. The
          endpoints of the line segments can be the starting or ending points,
          but they can also be points on the circular obstacles which are
          tangent to the line segments. The circular arcs are paths along the
          boundaries of the obstacles which link up the line segments.
        </p>

        <p>
          Also notice that the paths alternate between the two types. The first
          piece is always a line segment. If there is a direct path to the goal,
          this is the whole path. But if the path is longer, there is an arc
          next, followed by a segment. This may be the end of the path, or there
          may be more arc and segment pairs. The final piece is always a
          segment.
        </p>

        <p>
          [Diagram here: fixed start/end, two draggable obstacles]
        </p>

        <p>
          How can we use A* to generate this type of path? Let’s start with a
          review of how A* works.
        </p>

        <h2 id="a-algorithm">A* algorithm</h2>

        <p>
          A <em>partial path</em> is a series of steps from the start point to some
          intermediate point. A* works by evaluating a set of partial paths,
          generating new paths from the most promising path in the set, and
          terminating once it finds a complete path to the goal that it can
          prove to be better than any of the remaining possibilities. To do
          this, A* keeps the partial paths in a priority queue, sorted by
          estimated length. A partial path’s estimated length is the actual
          measured length of the path so far, plus a guess of the remaining
          distance to the goal. This guess must be an <em>underestimate</em>; that is,
          the guess can be less than the actual distance, but not greater. In
          most pathfinding problems, a good underestimate is the geometric
          straight-line distance from the intermediate point to the goal. The
          actual best path from an intermediate point to the goal might be
          longer than the straight line distance, but it can’t be shorter.
        </p>

        <p>
          When A* begins, the priority queue contains just one partial path: the
          start point. The algorithm works by repeatedly removing the most
          promising path from the priority queue. If this path ends at the goal
          point, the algorithm is done—the priority queue ensures that no
          other path could possibly be better. Otherwise, A* generates a set of
          new paths by taking single steps in all possible directions, and
          places these new paths back into the priority queue.
        </p>

        <h2 id="graph">Graph</h2>

        <p>
          A* works on a <em>graph</em>: a collection of <em>nodes</em> connected by
          <em>edges</em>. When generating new paths from a partial path that ends at
          node <em>q</em>, A* makes a new path for each edge leading out of <em>q</em>. In a
          grid-based world, each node represents an individual grid location,
          while each edge represents a connection to a neighboring location to
          the north, south, east and west.
        </p>

        <p>
          Before A* can run on the forest of round obstacles, we need to convert
          it into a graph. Remember that all the paths through the forest
          consist of alternating line segments and arc sections. The segments
          and arcs act as edges in the graph; the endpoints of the segments and
          arcs—and the start and goal points—become the nodes. A
          path through this graph is a series of nodes (that is, segment or arc
          endpoints) connected by edges (that is, segments or arcs).
        </p>

        [Diagram showing the path broken into segments and arcs with common endpoints]
        
        <p>
          Both segments and arcs act as edges in the graph. We’ll call the
          segments <em>surfing edges</em>, because the path uses them to surf between
          obstacles. The arcs we’ll call <em>hugging edges</em>, as their purpose in
          the path is to hug the sides of the obstacles.
        </p>

        <p>
          Next we’ll explore a simple way to turn the obstacle forest into a
          graph: generate all of the possible surfing and hugging edges.
        </p>

        <svg id="graph-all-edges" width="600" height="300">
          <a-draggable v-for="(A, index) in circles"
                       :key="index" :model="A">
            <circle :r="A.r" />
          </a-draggable>
          <circle v-for="A in circles"
                  :cx="A.x" :cy="A.y" :r="A.r"
                  fill="none" stroke="black" class="graph-edge" />
          <line v-for="edge in edges" class="graph-edge"
                :x1="edge[0].x" :y1="edge[0].y"
                :x2="edge[1].x" :y2="edge[1].y" />
          <circle v-for="edge in edges" class="graph-node"
                  :cx="edge[0].x" :cy="edge[0].y" r="5" />
          <circle v-for="edge in edges" class="graph-node"
                  :cx="edge[1].x" :cy="edge[1].y" r="5" />
        </svg>

        <h3 id="generating-surfing-edges">Generating surfing edges</h3>

        <p>
          The surfing edges between a pair of circles are the line segments
          which just barely kiss both circles; these segments are known as
          <em>bitangents</em>, and in general, there are four of them for each pair of
          circles. The bitangents which cross between the circles are the
          <em>internal bitangents</em>, while the ones which go along the outside are
          the <em>external bitangents</em>.
        </p>

        <h4 id="internal-bitangents">Internal bitangents</h4>

        <p>
          Historically, internal bitangents were important for calculating the
          length of a belt which crosses over two different sized pulleys, and
          so the problem of constructing internal bitangents is known as the <em>belt
          problem</em>.  To find the internal bitangents, calculate the angle \(\theta\)
          in the diagram below.
        </p>

        <svg id="belt-problem" width="600" height="300">
          <defs>
            <clipPath id="belt-problem-clip">
              <circle :cx="B.x" :cy="B.y" :r="B.r" />
            </clipPath>
          </defs>
          <a-draggable :model="A"><circle :r="A.r" /></a-draggable>
          <a-draggable :model="B"><circle :r="B.r" /></a-draggable>
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="none" stroke="black" />
          <circle :cx="B.x" :cy="B.y" :r="B.r" fill="none" stroke="black" />
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="hsl(0,20%,85%)" clip-path="url(#belt-problem-clip)" />
          <line class="dashed" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <template v-if="non_overlapping">
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="C.x" :y2="C.y" />
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="D.x" :y2="D.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="E.x" :y2="E.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="F.x" :y2="F.y" />
            <line class="graph-edge" :x1="C.x" :y1="C.y" :x2="F.x" :y2="F.y" />
            <line class="graph-edge" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
            <circle class="graph-node" :cx="C.x" :cy="C.y" r="5" />
            <circle class="graph-node" :cx="D.x" :cy="D.y" r="5" />
            <circle class="graph-node" :cx="E.x" :cy="E.y" r="5" />
            <circle class="graph-node" :cx="F.x" :cy="F.y" r="5" />
            <a-label :at="C" :opposite="A" label="C" />
            <a-label :at="D" :opposite="A" label="D" />
            <a-label :at="E" :opposite="B" label="E" />
            <a-label :at="F" :opposite="B" label="F" />
            <a-label :at="theta_AC" :opposite="A" label="θ" />
            <a-label :at="theta_AD" :opposite="A" label="θ" />
            <a-label :at="theta_BE" :opposite="B" label="θ" />
            <a-label :at="theta_BF" :opposite="B" label="θ" />
          </template>
          <template v-else="">
            <text x="300" y="15">Overlapping circles have no bitangents</text>
          </template>
        </svg>

        <p>
          It turns out that, given circles centered on points \(A\)
          and \(B\) with radii \(r_A\) and \(r_B\), and centers
          separated by distance \(d\):
 \[\theta = \arccos{{r_A+r_B}\over{d}}\]
 Note that when the two circles
          overlap, there are no internal bitangents; in this case
          \({r_A+r_B}\over d\) is greater than one. Since arccosine is
          undefined for inputs outside its domain of \([-1, 1]\), it's
          important to check for circle overlap before performing the
          arccosine.
        </p>

        <h4 id="external-bitangents">External bitangents</h4>

        <p>
          Constructing external bitangents—the <em>pulley problem</em>—uses a
          similar technique.
        </p>

        <svg id="pulley-problem" width="600" height="300">
          <defs>
            <clipPath id="pulley-problem-clip">
              <circle :cx="B.x" :cy="B.y" :r="B.r" />
            </clipPath>
          </defs>
          <a-draggable :model="A"><circle :r="A.r" /></a-draggable>
          <a-draggable :model="B"><circle :r="B.r" /></a-draggable>
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="none" stroke="black" />
          <circle :cx="B.x" :cy="B.y" :r="B.r" fill="none" stroke="black" />
          <circle :cx="A.x" :cy="A.y" :r="A.r" :fill="non_containing?'hsl(240,25%,85%)':'hsl(0,20%,85%)'" clip-path="url(#pulley-problem-clip)" />
          <line class="dashed" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <template v-if="non_containing">
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="C.x" :y2="C.y" />
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="D.x" :y2="D.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="E.x" :y2="E.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="F.x" :y2="F.y" />
            <line class="graph-edge" :x1="C.x" :y1="C.y" :x2="F.x" :y2="F.y" />
            <line class="graph-edge" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
            <circle class="graph-node" :cx="C.x" :cy="C.y" r="5" />
            <circle class="graph-node" :cx="D.x" :cy="D.y" r="5" />
            <circle class="graph-node" :cx="E.x" :cy="E.y" r="5" />
            <circle class="graph-node" :cx="F.x" :cy="F.y" r="5" />
            <a-label :at="C" :opposite="A" label="C" />
            <a-label :at="D" :opposite="A" label="D" />
            <a-label :at="E" :opposite="B" label="E" />
            <a-label :at="F" :opposite="B" label="F" />
            <a-label :at="theta_AC" :opposite="A" label="θ" />
            <a-label :at="theta_AD" :opposite="A" label="θ" />
            <a-label :at="theta_BE" :opposite="B" label="θ" />
            <a-label :at="theta_BF" :opposite="B" label="θ" />
          </template>
          <template v-else="">
            <text x="300" y="15">Smaller circle entirely contained in larger one</text>
          </template>
        </svg>

        <p>
          For external bitangents we can find \(\theta\) like this:
 \[\theta = \arccos{{r_A - r_B} \over d}\]

 It doesn’t matter whether circle A or B is bigger, but as shown in
          the diagram, \(\theta\) appears on the side of A toward B,
          but on the side of B away from A. If one circle completely
          encloses the other, then there are no external
          bitangents. In this case \({r_A - r_B} \over d\) is outside
          the range \([-1, 1]\). Again, because arccosine is undefined
          for such inputs, it's important to check for this case
          first.

        </p>

        <h4 id="surfing-line-of-sight">Line of sight</h4>

        <p>
          Taken together, the internal and external bitangents between two
          circles constitute surfing edges between the circles. But what if a
          third circle blocks one or more of the surfing edges?
        </p>

        <p>
          If a surfing edge is blocked by another circle, we need to throw the
          edge out.  To detect this case, we use a simple <em>point-line-distance</em>
          calculation. If the distance from the surfing edge to the obstacle’s
          center is less than the obstacle’s radius, then the obstacle blocks
          the surfing edge, and we should throw the edge away.
        </p>

        <svg id="surfing-line-of-sight-diagram" width="600" height="300">
          <defs>
            <clipPath id="surfing-line-of-sight-clip">
              <circle :cx="C.x" :cy="C.y" :r="C.r" />
            </clipPath>
          </defs>
          <line class="graph-edge" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <a-draggable :model="C"><circle :r="C.r" /></a-draggable>
          <line class="graph-edge" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" clip-path="url(#surfing-line-of-sight-clip)" style="stroke:hsl(0,50%,50%);stroke-width:3px" />
          <circle class="graph-node" :cx="A.x" :cy="A.y" r="5" />
          <circle class="graph-node" :cx="B.x" :cy="B.y" r="5" />
          <circle :cx="C.x" :cy="C.y" r="3" fill="black" />
          <circle :cx="D.x" :cy="D.y" r="3" fill="black" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <a-label :at="C" :opposite="D" label="C" />
          <a-label :at="D" :opposite="C" label="D" />
          <line class="dashed" :x1="C.x" :y1="C.y" :x2="D.x" :y2="D.y" />
          <circle :cx="C.x" :cy="C.y" :r="C.r" fill="none" stroke="black" />
          <text x="300" y="275">
            <template v-if="intersects">Circle blocks line of sight</template>
            <template v-else>A and B visible from each other</template>
          </text>
        </svg>
        
        <p>
          To calculate the distance from point \(C\) to line segment \(\overline{AB}\),
          use the following method
          (from <a href="http://paulbourke.net/geometry/pointlineplane/">Paul
          Bourke</a>):
        </p>
        
        <p>
          First, compute \(u\), the fraction of the distance along
          segment \(\overline{AB}\) at which a perpendicular ascender
          hits point \(C\):
        </p>

<p>
\[ u = {(C - A) \cdot (B-A) \over (B-A)\cdot(B-A)}  \]

or equivalently:

          \[u = {{(x_C - x_A)(x_B - x_A) + (y_C - y_A)(y_B - y_A)} \over
          {(x_B - x_A)(x_B - x_A) + (y_B - y_A)(y_B - y_A)}} \]

If \(u\) is outside the range of \([0,1]\), then the perpendicular
strikes the \(\overline{AB}\) line somewhere outside the
\(\overline{AB}\) segment. By clamping \(u\) inside \([0,1]\), we can
find point \(D\), the closest point to \(C\) on the \(\overline{AB}\)
segment:
          \[D = A + clamp(u, 0, 1) * (B - A)\]

Thus, the distance from \(C\) to segment \(\overline{AB}\) is the distance from \(C\) to \(D\):

 \[d = \|D - C\|\]
</p>


        <h3 id="generating-hugging-edges">Generating hugging edges</h3>

        <p>
          Each hugging edge starts at the endpoint of a surfing edge, traverses
          around the circle, and terminates at the endpoint of a different
          surfing edge.
        </p>

        <svg id="hugging-edge" width="600" height="300">
          <template v-if="valid">
            <line :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" fill="none" stroke="black" />
            <line :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" fill="none" stroke="black" />
          </template>
          <a-draggable :model="A"><circle r="10" /></a-draggable>
          <a-draggable :model="E"><circle r="10" /></a-draggable>
          <a-draggable :model="C"><circle :r="C.r" /></a-draggable>
          <template v-if="valid">
            <line class="dashed" :x1="C.x" :y1="C.y" :x2="B.x" :y2="B.y" />
            <line class="dashed" :x1="C.x" :y1="C.y" :x2="D.x" :y2="D.y" />
            <a-label :at="C" :opposite="mid_BD" label="C" />
            <a-label :at="B" :opposite="C" label="B" />
            <a-label :at="D" :opposite="C" label="D" />
          </template>
          <circle :cx="C.x" :cy="C.y" :r="C.r" fill="none" stroke="black" />
          <template v-if="valid">
            <path class="graph-edge" :d="arc_path" />
            <circle class="graph-node" :cx="B.x" :cy="B.y" r="5" />
            <circle class="graph-node" :cx="D.x" :cy="D.y" r="5" />
          </template>
        </svg>

        <p>
          [TODO: is left/right an optimization we can leave for later, or do we need a diagram to show it now?]
        </p>

        <p>
          Hugging edges connect surfing edges which touch the same circle, but
          not every pair of surfing edges which touch a circle can be connected
          by a hugging edge. Each surfing edge touching a circle can be
          classified into one of two types: <em>left</em> edges and <em>right</em>
          edges. Viewed from the endpoint which is not touching the circle, left
          surfing edges intersect the left side of the circle, while right edges
          touch the circle on the right side. Every hugging edge connects a left
          surfing edge and a right surfing edge; if one were to traverse the
          hugging edge from the left surfing edge to the right surfing edge,
          travel around the circle would be clockwise.
        </p>

        <p>
          [Interactive diagram: three draggable circles with all bitangents
          drawn, with each bitangent endpoint drawn red or blue depending on
          whether they are left or right edges on that circle.]
        </p>

        <p>
          To find the set of hugging edges for a circle, first collect all the
          surfing edge endpoints on the circle. Then for each left surfing edge
          endpoint, generate a hugging edge to each right surfing edge endpoint,
          traversing the circle clockwise. Because the graph is undirected, each
          of these hugging edges implies the existence of another hugging edge
          which starts at a right edge, traverses around the circle
          anticlockwise, and terminates on a left edge.
        </p>

        <h4 id="hugging-line-of-sight">Line of sight</h4>

        <p>
          Hugging edges can be blocked by obstacles just as surfing edges
          can. Consider the hugging edge in the diagram below. If another
          obstacle touches the hugging edge, it’s blocked and should be thrown
          out.
        </p>

        <p>
          [Diagram with a fixed hugging edge between two points on the circle. A
          second circle can be dragged; if it touches the hugging edge, the edge
          gets grayed out.]
        </p>

        <p>
          To determine whether a hugging edge is blocked by another
          obstacle, use the following method
          by <a href="http://paulbourke.net/geometry/circlesphere/">Paul
          Bourke</a> to determine the points at which the two circles
          intersect.  Given circles centered on points \(A\) and \(B\)
          with radii \(r_A\) and \(r_B\), where \(d\) is the distance
          between \(A\) and \(B\), there are a few cases to check for
          first. If the circles are not touching (that is, \(d > r_A + r_B\)),
          if one circle is inside the other (\(d < |r_A - r_B|\)), or
          the circles are coincident (\(d = 0\) and \(r_A = r_B\)),
          then the circles cannot interfere with each others' hugging
          edges.
        </p>
        <p>
          If none of these cases hold, then the circles intersect at two
          points&mdash;if the circles are tangent to each other, these two
          points are coincident. Consider the <em>radical line</em> which
          connects the intersection points; it's perpendicular to the line
          connecting \(A\) and \(B\) at some point \(C\). We can calculate the
          distance \(a\) from \(A\) to \(C\) as follows:

          \[a = {r_A^2 - r_B^2 + d^2 \over 2d } \]

          Having found \(a\), we can find the angle \(\theta\):
\[\theta = \arccos {a \over r_A} \]
 If \(\theta\) is zero, the circles are
          tangent at \(C\). Otherwise, there are two intersection
          points, corresponding to positive and negative \(\theta\).
        </p>

        <svg id="circle-overlap" width="600" height="300">
          <a-draggable :model="A"><circle :r="A.r" /></a-draggable>
          <a-draggable :model="B"><circle :r="B.r" /></a-draggable>
          <line class="dashed" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <line v-if="valid" class="dashed" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
          <line v-if="valid" class="dashed" :x1="A.x" :y1="A.y" :x2="D.x" :y2="D.y" />
          <line v-if="valid" class="dashed" :x1="A.x" :y1="A.y" :x2="E.x" :y2="E.y" />
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="none" stroke="black" />
          <circle :cx="B.x" :cy="B.y" :r="B.r" fill="none" stroke="black" />
          <circle :cx="A.x" :cy="A.y" r="3" fill="black" />
          <circle :cx="B.x" :cy="B.y" r="3" fill="black" />
          <circle :cx="C.x" :cy="C.y" r="3" fill="black" />
          <circle v-if="valid" :cx="D.x" :cy="D.y" r="3" fill="black" />
          <circle v-if="valid" :cx="E.x" :cy="E.y" r="3" fill="black" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <a-label :at="C" :opposite="B" label="C" />
          <a-label v-if="valid" :at="theta_AC" :opposite="A" label="θ" />
          <a-label v-if="valid" :at="theta_AD" :opposite="A" label="θ" />
          <a-label v-if="valid" :at="D" :opposite="C" label="D" />
          <a-label v-if="valid" :at="E" :opposite="C" label="E" />
          <text x="300" y="275">
            TODO: detect and describe cases
          </text>
        </svg>

        <p>
          Next, determine whether either of the intersection points fall between
          the start and end points of the hugging edge. If this is the case,
          then the obstacle blocks the hugging edge, and we should discard the
          edge.  Note that we don’t have to worry about the case where the
          hugging edge is entirely contained within an obstacle, as the line of
          sight culling for surfing edges will have already thrown the edge out.
        </p>

        <h3 id="nodes">Nodes</h3>

        <p>
          Other that the start and end points, the graph’s nodes are the
          endpoints of hugging edges.  Some hugging edges may share endpoints,
          and these can be coalesced into single nodes. This should happen only
          if the shared endpoint is on the same end of the hugging edge. The
          left endpoint of a hugging edge shouldn’t coalesce with the right
          endpoint of another hugging edge.
        </p>

        <h2 id="putting-it-all-together">Putting it all together</h2>

        <p>
          Given Minkowski expansion of obstacles, the generation of surfing and
          hugging edges, and the culling of blocked edges, we can run
          pathfinding using the A* algorithm.
        </p>

        <p>
          [Diagram: full demo]
        </p>

        <h2 id="enhancements">Enhancements</h2>

        <p>
          We could just eliminate this section for the first version.
        </p>

        <h3 id="delayed-edge-generation">Delayed edge generation</h3>

        <p>
In general, the graph for a forest of \(n\) obstacles contains
\(O(n^2)\) surfing edges, but since each of these must be checked for
line of sight against \(n\) obstacles, the total time to generate the
graph is \(O(n^3)\). Additionally, pairs of surfing edges can induce
hugging edges, and each of these must be checked against every
obstacle for line of sight.  However, because the A* algorithm is so
efficient, it normally looks at only a fraction of this large graph to
produce an optimal path.

<p>
          [Diagram showing which graph edges were even looked at.]
</p>
<p>
We can save time by generating small portions of the graph on the fly
as we proceed through the A* algorithm, rather than doing all of the
work up front. If A* finds a path quickly, we'll generate only a small
part of the graph. We do this by moving edge generation to the
neighbors() function.
        </p>

<p>
There are several cases. At the beginning of the algorithm, we need the
neighbors of the start point. These are surfing edges from the start point
to the left and right edges of each obstacle.
</p>
<p>
The next case is when A* has just arrived at point \(p\) on on the
edge of obstacle \(C\) along a surfing edge. Neighbors() needs to
return the hugging edges leading from \(p\). To do this determine
which surfing edges leave the obstacle by computing the bitangents
between \(C\) and every other obstacle, throwing away any that do not
have line of sight. Then find all the hugging edges that connect \(p\)
to these surfing edges, discarding those that are blocked by other
obstacles. Return all of these hugging edges, saving the surfing edges
for return in a subsequent neighbors() call.
</p>
<p>
The last case is when A* has traversed a hugging edge along obstacle
\(C\) and needs to leave the \(C\) via a surfing edge. Because the
previous step calculated and saved all the surfing edges, the correct
set of edges can just be looked up and returned.
</p>

<h3>Store path tree in an array</h3>

Don't store each path separately; put them in a tree stored in an array.

        <h3 id="cull-longer-paths-to-same-place">Cull longer paths to same place</h3>

        <p>
          Before putting new paths into the priority queue, see if we’ve been to
          this spot going the same direction for a cheaper cost already.
        </p>

        <h3 id="crossing-edge-culling">Crossing edge culling</h3>

        <p>
          Cull partial paths whose final surfing edge crosses the penultimate
          surfing edge.
        </p>

        <h3 id="polygonal-obstacles">Polygonal obstacles</h3>

        <p>
          exercise for the reader
        </p>

        <h3 id="spatial-index">Spatial index</h3>

        <h2 id="full-demo">Full demo</h2>

        <h2 id="references">References</h2>

        <ul>
          <li>Belt problem</li>
          <li>Pulley problem</li>
          <li>Point line distance</li>
          <li>Intersection of two circles</li>
        </ul>
        
      </div>
    </section>

    <footer>
      <svg width="0" height="0">
        <defs>
          <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
            <feOffset dx="0" dy="1" result="offsetblur" />
            <feFlood flood-color="#000000" />
            <feComposite in2="offsetblur" operator="in" />
            <feMerge>
              <feMergeNode />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
      </svg>

      <script>
        renderMathInElement(document.body);
      </script>
      <script src="https://unpkg.com/vue"></script>
      <script src="lib.js"></script>
      <script src="components.js"></script>
      <script src="belt-problem.js"></script>
      <script src="graph-diagrams.js"></script>
      
      <div>
        <p class="copyright">Copyright 2017 by <a href="https://github.com/redblobgames">redblobgames</a> and <a href="https://github.com/shillingsburg">shillingsburg</a>
        </p>
      </div>
    </footer>

  </body>
</html>
