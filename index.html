<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <link rel="stylesheet" type="text/css" media="screen" href="style.css"/>
    <title>Circular Obstacle Pathfinding</title>
    <meta name="description" content="Pathfinding around a set of circular obstacles"/>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css" integrity="sha384-wITovz90syo1dJWVh32uuETPVEtGigN07tkttEqPv+uR2SE/mbQcG7ATL28aI9H0" crossorigin="anonymous">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.js" integrity="sha384-/y1Nn9+QQAipbNQWU65krzJralCnuOasHncUFXGkdwntGeSvQicrYkiUBwsgUqc1" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/contrib/auto-render.min.js" integrity="sha384-dq1/gEHSxPZQ7DdrM82ID4YVol9BYyU7GbWlIwnwyPzotpoc57wDw/guX8EaYGPx" crossorigin="anonymous"></script>    
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/redblobgames/circular-obstacle-pathfinding">View on GitHub</a>
    <header>
      <div>
        <h1>Circular Obstacle Pathfinding</h1>
        <h2>Pathfinding around a set of circular obstacles</h2>
      </div>
    </header>

    <section id="main_content">
      <div>
        
        <address>Mar 2017</address>

        <h2 id="navigating-a-forest">Navigating a forest</h2>

        <p>
          The A* pathfinding algorithm is a powerful method for quickly
          generating optimal paths. Typically, people demonstrate A* navigating
          grid-based maps such as this one, avoiding obstacles to reach a goal.
        </p>

        <p>
          [Diagram here]
        </p>

        <p>
          But A* isn’t just a grid algorithm! It can work on any
          graph. We can use A* to find a path through this world of
          round obstacles.
        </p>

        <p>
          [TODO: calculate A* on this graph]
        </p>

        <svg id="diagram-graph-busy-edges" width="600" height="300">
          <a-draggable v-for="(A, index) in circles"
                       :key="index" :model="A">
            <circle :r="Math.max(A.r, 5)" />
          </a-draggable>
          <circle v-for="A in circles"
                  class="hugging-edge"
                  :cx="A.x" :cy="A.y" :r="A.r"
                  style="stroke-width: 2px" />
          <line v-for="edge in edges" class="surfing-edge"
                :x1="edge[0].x" :y1="edge[0].y"
                :x2="edge[1].x" :y2="edge[1].y"
                style="stroke-width: 1px" />
          <circle v-for="edge in edges" class="graph-node"
                  :cx="edge[0].x" :cy="edge[0].y" r="2" />
          <circle v-for="edge in edges" class="graph-node"
                  :cx="edge[1].x" :cy="edge[1].y" r="2" />
        </svg>

        <p>
          How does the same algorithm solve both problems?
Let’s start with a
          review of how A* works.
        </p>

        <h2 id="a-algorithm">A* algorithm</h2>

<p>
The A* algorithm finds the <em>optimal path</em> from the start point
to the end point, avoiding obstacles along the way. It does this by
gradually expanding a set of <em>partial paths</em>. Each partial path
is a series of steps from the start point to some intermediate point
on the way to the goal.  As A* progresses, the partial paths get
closer and closer to the goal point. The algorithm terminates once it
finds a complete path that it can prove to be better than any of the
remaining possibilities.
</p>

        <p>
          At each step in the algorithm, A* evaluates the set of
          partial paths and generates some new paths by expanding the
          most promising path in the set. To do this, A* keeps the
          partial paths in a priority queue, sorted by <em>estimated
          length</em>&mdash;the actual measured length of the path so
          far, plus a guess of the remaining distance to the
          goal. This guess must be an <em>underestimate</em>; that is,
          the guess can be less than the actual distance, but not
          greater. In most pathfinding problems, a good underestimate
          is the geometric straight-line distance from the end of the
          partial path to the goal. The actual best path to the goal
          from the end of the partial path might be longer than this
          straight line distance, but it can’t be shorter.
        </p>

        <p>
          When A* begins, the priority queue contains just one partial
          path: the start point. The algorithm works by repeatedly
          removing the most promising path from the priority queue,
          that is, the path with the smallest estimated length. If
          this path ends at the goal point, the algorithm is done—the
          priority queue ensures that no other path could possibly be
          better. Otherwise, A* generates a set of new paths by taking
          single steps in all possible directions, and places these
          new paths back into the priority queue.
        </p>

        <h2 id="graph">Graph</h2>

        <p>
          A* works on a <em>graph</em>: a collection of <em>nodes</em> connected by
          <em>edges</em>. When generating new paths from a partial path that ends at
          node <em>q</em>, A* makes a new path for each edge leading out of <em>q</em>. In a
          grid-based world, each node represents an individual grid location,
          while each edge represents a connection to a neighboring location to
          the north, south, east and west.
        </p>

        <p>
          Before A* can run on the forest of round obstacles, we need
          to convert it into a graph. All the paths through the forest
          consist of alternating line segments

          <svg class="plain" width="5em" height="1em" viewBox="0 0 100 20">
            <path class="surfing-edge" d="M 10,12 L 90,12" />
            <circle class="graph-node" cx="10" cy="12" r="4" />
            <circle class="graph-node" cx="90" cy="12" r="4" />
          </svg>

          and arc sections

          <svg class="plain" width="5em" height="1em" viewBox="0 0 100 20">
            <path class="hugging-edge" d="M 10,20 A 50,50 0 0 1 90,20" />
            <circle class="graph-node" cx="10" cy="20" r="4" />
            <circle class="graph-node" cx="90" cy="20" r="4" />
          </svg>

          . These are edges in the path graph. The endpoints of these
          edges become nodes

          <svg class="plain" width="1em" height="1em" viewBox="0 0 20 20">
            <circle class="graph-node" cx="10" cy="10" r="8" />
          </svg>

          . A path through the graph is a series of nodes connected by edges

          <svg class="plain" width="10em" height="1em" viewBox="0 0 200 20">
            <path class="surfing-edge" d="M 5,18 L 60,18" />
            <path class="hugging-edge" d="M 60,18 A 50,50 0 0 1 140,18" />
            <path class="surfing-edge" d="M 140,18 L 195,18" />
            <circle class="graph-node" cx="5" cy="18" r="5" />
            <circle class="graph-node" cx="60" cy="18" r="5" />
            <circle class="graph-node" cx="140" cy="18" r="5" />
            <circle class="graph-node" cx="195" cy="18" r="5" />
          </svg>
          
          . [<em>Note: the surfing edges in this little picture are not
          tangent to the hugging edge, and I think this might be
          misleading.</em>]
        </p>

        <svg id="diagram-one-path" width="600" height="300">
          <circle cx="340" cy="200" r="90" fill="none" stroke="black" class="hugging-edge"></circle>
          <line x1="75" y1="270" x2="333" y2="290" class="surfing-edge"></line>
          <line x1="543" y1="97" x2="409" y2="258" class="surfing-edge"></line>
          <circle cx="75" cy="270" r="5" class="graph-node"></circle>
          <circle cx="333" cy="290" r="5" class="graph-node"></circle>
          <circle cx="543" cy="97" r="5" class="graph-node"></circle>
          <circle cx="409" cy="258" r="5" class="graph-node"></circle>
          <text y="20" x="300">PLACEHOLDER</text>
        </svg>
        
        <p>
          Both segments and arcs act as edges in the graph. We’ll call the
          segments <em>surfing edges</em>, because the path uses them to surf between
          obstacles. The arcs we’ll call <em>hugging edges</em>, as their purpose in
          the path is to hug the sides of the obstacles.
        </p>

        <p>
          Next we’ll explore a simple way to turn the obstacle forest into a
          graph: generate all of the possible surfing and hugging edges.
        </p>

        <svg id="diagram-graph-all-edges" width="600" height="300">
          <a-draggable v-for="(A, index) in circles"
                       :key="index" :model="A">
            <circle :r="Math.max(A.r, 5)" />
          </a-draggable>
          <circle v-for="A in circles"
                  :cx="A.x" :cy="A.y" :r="A.r"
                  fill="none" stroke="black" class="hugging-edge" />
          <line v-for="edge in edges" class="surfing-edge"
                :x1="edge[0].x" :y1="edge[0].y"
                :x2="edge[1].x" :y2="edge[1].y" />
          <circle v-for="edge in edges" class="graph-node"
                  :cx="edge[0].x" :cy="edge[0].y" r="5" />
          <circle v-for="edge in edges" class="graph-node"
                  :cx="edge[1].x" :cy="edge[1].y" r="5" />
        </svg>

        <h3 id="generating-surfing-edges">Generating surfing edges</h3>

        <p>
          The surfing edges between a pair of circles are the line segments
          which just barely kiss both circles; these segments are known as
          <em>bitangents</em>, and in general, there are four of them for each pair of
          circles. The bitangents which cross between the circles are the
          <em>internal bitangents</em>, while the ones which go along the outside are
          the <em>external bitangents</em>.
        </p>

        <h4 id="internal-bitangents">Internal bitangents</h4>

        <p>
          Historically, internal bitangents were important for calculating the
          length of a belt which crosses over two different sized pulleys, and
          so the problem of constructing internal bitangents is known as the <em>belt
          problem</em>.  To find the internal bitangents, calculate the angle \(\theta\)
          in the diagram below.
        </p>

        <svg id="diagram-belt-problem" width="600" height="300">
          <defs>
            <clipPath id="belt-problem-clip">
              <circle :cx="B.x" :cy="B.y" :r="B.r" />
            </clipPath>
          </defs>
          <a-draggable :model="A"><circle :r="A.r" /></a-draggable>
          <a-draggable :model="B"><circle :r="B.r" /></a-draggable>
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="none" stroke="black" />
          <circle :cx="B.x" :cy="B.y" :r="B.r" fill="none" stroke="black" />
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="hsl(0,20%,85%)" clip-path="url(#belt-problem-clip)" />
          <line class="dashed" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <template v-if="non_overlapping">
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="C.x" :y2="C.y" />
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="D.x" :y2="D.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="E.x" :y2="E.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="F.x" :y2="F.y" />
            <line class="surfing-edge" :x1="C.x" :y1="C.y" :x2="F.x" :y2="F.y" />
            <line class="surfing-edge" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
            <circle class="graph-node" :cx="C.x" :cy="C.y" r="5" />
            <circle class="graph-node" :cx="D.x" :cy="D.y" r="5" />
            <circle class="graph-node" :cx="E.x" :cy="E.y" r="5" />
            <circle class="graph-node" :cx="F.x" :cy="F.y" r="5" />
            <a-label :at="C" :opposite="A" label="C" />
            <a-label :at="D" :opposite="A" label="D" />
            <a-label :at="E" :opposite="B" label="E" />
            <a-label :at="F" :opposite="B" label="F" />
            <a-label :at="theta_AC" :opposite="A" label="θ" />
            <a-label :at="theta_AD" :opposite="A" label="θ" />
            <a-label :at="theta_BE" :opposite="B" label="θ" />
            <a-label :at="theta_BF" :opposite="B" label="θ" />
          </template>
          <template v-else="">
            <text x="300" y="15">Overlapping circles have no bitangents</text>
          </template>
        </svg>

        <p>
          It turns out that, given circles centered on points \(A\)
          and \(B\) with radii \(r_A\) and \(r_B\), and centers
          separated by distance \(d\):
          \[\theta = \arccos{{r_A+r_B}\over{d}}\]
          Note that when the two circles
          overlap, there are no internal bitangents; in this case
          \({r_A+r_B}\over d\) is greater than one. Since arccosine is
          undefined for inputs outside its domain of \([-1, 1]\), it's
          important to check for circle overlap before performing the
          arccosine.
        </p>

        <h4 id="external-bitangents">External bitangents</h4>

        <p>
          Constructing external bitangents—the <em>pulley problem</em>—uses a
          similar technique.
        </p>

        <svg id="diagram-pulley-problem" width="600" height="300">
          <defs>
            <clipPath id="pulley-problem-clip">
              <circle :cx="B.x" :cy="B.y" :r="B.r" />
            </clipPath>
          </defs>
          <a-draggable :model="A"><circle :r="A.r" /></a-draggable>
          <a-draggable :model="B"><circle :r="B.r" /></a-draggable>
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="none" stroke="black" />
          <circle :cx="B.x" :cy="B.y" :r="B.r" fill="none" stroke="black" />
          <circle :cx="A.x" :cy="A.y" :r="A.r" :fill="containing?'hsl(0,20%,85%)':'hsl(240,25%,85%)'" clip-path="url(#pulley-problem-clip)" />
          <line class="dashed" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <template v-if="!containing">
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="C.x" :y2="C.y" />
            <line class="dashed" :x1="A.x" :y1="A.y" :x2="D.x" :y2="D.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="E.x" :y2="E.y" />
            <line class="dashed" :x1="B.x" :y1="B.y" :x2="F.x" :y2="F.y" />
            <line class="surfing-edge" :x1="C.x" :y1="C.y" :x2="F.x" :y2="F.y" />
            <line class="surfing-edge" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
            <circle class="graph-node" :cx="C.x" :cy="C.y" r="5" />
            <circle class="graph-node" :cx="D.x" :cy="D.y" r="5" />
            <circle class="graph-node" :cx="E.x" :cy="E.y" r="5" />
            <circle class="graph-node" :cx="F.x" :cy="F.y" r="5" />
            <a-label :at="C" :opposite="A" label="C" />
            <a-label :at="D" :opposite="A" label="D" />
            <a-label :at="E" :opposite="B" label="E" />
            <a-label :at="F" :opposite="B" label="F" />
            <a-label :at="theta_AC" :opposite="A" label="θ" />
            <a-label :at="theta_AD" :opposite="A" label="θ" />
            <a-label :at="theta_BE" :opposite="B" label="θ" />
            <a-label :at="theta_BF" :opposite="B" label="θ" />
          </template>
          <template v-else="">
            <text x="300" y="15">Smaller circle entirely contained in larger one</text>
          </template>
        </svg>

        <p>
          For external bitangents we can find \(\theta\) like this:
          \[\theta = \arccos{{r_A - r_B} \over d}\]

          It doesn’t matter whether circle A or B is bigger, but as shown in
          the diagram, \(\theta\) appears on the side of A toward B,
          but on the side of B away from A. If one circle completely
          encloses the other, then there are no external
          bitangents. In this case \({r_A - r_B} \over d\) is outside
          the range \([-1, 1]\). Again, because arccosine is undefined
          for such inputs, it's important to check for this case
          first.

        </p>

        <h4 id="surfing-line-of-sight">Line of sight</h4>

        <p>
          Taken together, the internal and external bitangents between two
          circles constitute surfing edges between the circles. But what if a
          third circle blocks one or more of the surfing edges?
        </p>

        <p>
          If a surfing edge is blocked by another circle, we need to throw the
          edge out.  To detect this case, we use a simple <em>point-line-distance</em>
          calculation. If the distance from the surfing edge to the obstacle’s
          center is less than the obstacle’s radius, then the obstacle blocks
          the surfing edge, and we should throw the edge away.
        </p>

        <svg id="diagram-surfing-line-of-sight" width="600" height="300">
          <defs>
            <clipPath id="surfing-line-of-sight-clip">
              <circle :cx="C.x" :cy="C.y" :r="C.r" />
            </clipPath>
          </defs>
          <line class="surfing-edge" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <a-draggable :model="C"><circle :r="C.r" /></a-draggable>
          <line class="surfing-edge invalid-edge" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" clip-path="url(#surfing-line-of-sight-clip)"/>
          <circle class="graph-node" :cx="A.x" :cy="A.y" r="5" />
          <circle class="graph-node" :cx="B.x" :cy="B.y" r="5" />
          <circle :cx="C.x" :cy="C.y" r="3" fill="black" />
          <circle :cx="D.x" :cy="D.y" r="3" fill="black" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <a-label :at="C" :opposite="D" label="C" />
          <a-label :at="D" :opposite="C" label="D" />
          <line class="dashed" :x1="C.x" :y1="C.y" :x2="D.x" :y2="D.y" />
          <circle :cx="C.x" :cy="C.y" :r="C.r" fill="none" stroke="black" />
          <text x="300" y="275">
            <template v-if="intersects">Circle blocks line of sight</template>
            <template v-else>A and B visible from each other</template>
          </text>
        </svg>
        
        <p>
          To calculate the distance from point \(C\) to line segment \(\overline{AB}\),
          use the following method
          (from <a href="http://paulbourke.net/geometry/pointlineplane/">Paul
          Bourke</a>):
        </p>
        
        <p>
          First, compute \(u\), the fraction of the distance along
          segment \(\overline{AB}\) at which a perpendicular ascender
          hits point \(C\):
        </p>

        <p>
          \[ u = {(C - A) \cdot (B-A) \over (B-A)\cdot(B-A)}  \]

          or equivalently:

          \[u = {{(x_C - x_A)(x_B - x_A) + (y_C - y_A)(y_B - y_A)} \over
          {(x_B - x_A)(x_B - x_A) + (y_B - y_A)(y_B - y_A)}} \]

          If \(u\) is outside the range of \([0,1]\), then the perpendicular
          strikes the \(\overline{AB}\) line somewhere outside the
          \(\overline{AB}\) segment. By clamping \(u\) inside \([0,1]\), we can
          find point \(D\), the closest point to \(C\) on the \(\overline{AB}\)
          segment:
          \[D = A + clamp(u, 0, 1) * (B - A)\]

          Thus, the distance from \(C\) to segment \(\overline{AB}\) is the distance from \(C\) to \(D\):

          \[d = \|D - C\|\]
        </p>


        <h3 id="generating-hugging-edges">Generating hugging edges</h3>

        <p>
          Each hugging edge starts at the endpoint of a surfing edge, traverses
          around the circle, and terminates at the endpoint of a different
          surfing edge.
        </p>

        <svg id="diagram-hugging-edge" width="600" height="300">
          <template v-if="valid">
            <line class="surfing-edge" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
            <line class="surfing-edge" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
          </template>
          <a-draggable :model="A"><circle r="5" /></a-draggable>
          <a-draggable :model="E"><circle r="5" /></a-draggable>
          <a-draggable :model="C"><circle :r="C.r" /></a-draggable>
          <template v-if="valid">
            <line class="dashed" :x1="C.x" :y1="C.y" :x2="B.x" :y2="B.y" />
            <line class="dashed" :x1="C.x" :y1="C.y" :x2="D.x" :y2="D.y" />
            <a-label :at="C" :opposite="mid_BD" label="C" />
            <a-label :at="B" :opposite="C" label="B" />
            <a-label :at="D" :opposite="C" label="D" />
          </template>
          <circle class="graph-node" :cx="A.x" :cy="A.y" r="5" />
          <circle class="graph-node" :cx="E.x" :cy="E.y" r="5" />
          <circle :cx="C.x" :cy="C.y" :r="C.r" fill="none" stroke="black" />
          <template v-if="valid">
            <path class="hugging-edge" :d="arc_path" />
            <circle class="graph-node" :cx="B.x" :cy="B.y" r="5" />
            <circle class="graph-node" :cx="D.x" :cy="D.y" r="5" />
          </template>
        </svg>


<p>
To find the set of hugging edges for a circle, first find all the
surfing edges that touch the circle. Then, create hugging edges between all the surfing
edge endpoints on the circle.

</p>

        <h4 id="hugging-line-of-sight">Line of sight</h4>

        <p>
          Hugging edges can be blocked by obstacles just as surfing edges
          can. Consider the hugging edge in the diagram below. If another
          obstacle touches the hugging edge, it’s blocked and should be thrown
          out.
        </p>

        <p>
          [Diagram with a fixed hugging edge between two points on the circle. A
          second circle can be dragged; if it touches the hugging edge, the edge
          gets grayed out.]
        </p>

        <p>
          To determine whether a hugging edge is blocked by another
          obstacle, use the following method
          by <a href="http://paulbourke.net/geometry/circlesphere/">Paul
          Bourke</a> to determine the points at which the two circles
          intersect.  Given circles centered on points \(A\) and \(B\)
          with radii \(r_A\) and \(r_B\), where \(d\) is the distance
          between \(A\) and \(B\), there are a few cases to check for
          first. If the circles are not touching (that is, \(d > r_A + r_B\)),
          if one circle is inside the other (\(d < |r_A - r_B|\)), or
          the circles are coincident (\(d = 0\) and \(r_A = r_B\)),
          then the circles cannot interfere with each others' hugging
          edges.
        </p>
        
        <p>
          If none of these cases hold, then the circles intersect at two
          points&mdash;if the circles are tangent to each other, these two
          points are coincident. Consider the <em>radical line</em> which
          connects the intersection points; it's perpendicular to the line
          connecting \(A\) and \(B\) at some point \(C\). We can calculate the
          distance \(a\) from \(A\) to \(C\) as follows:
          
          \[a = {r_A^2 - r_B^2 + d^2 \over 2d } \]

          Having found \(a\), we can find the angle \(\theta\):
          \[\theta = \arccos {a \over r_A} \]
          If \(\theta\) is zero, the circles are
          tangent at \(C\). Otherwise, there are two intersection
          points, corresponding to positive and negative \(\theta\).
        </p>

        <svg id="diagram-circle-overlap" width="600" height="300">
          <a-draggable :model="A"><circle :r="A.r" /></a-draggable>
          <a-draggable :model="B"><circle :r="B.r" /></a-draggable>
          <line class="dashed" :x1="A.x" :y1="A.y" :x2="B.x" :y2="B.y" />
          <line v-if="valid" class="dashed" :x1="D.x" :y1="D.y" :x2="E.x" :y2="E.y" />
          <line v-if="valid" class="dashed" :x1="A.x" :y1="A.y" :x2="D.x" :y2="D.y" />
          <line v-if="valid" class="dashed" :x1="A.x" :y1="A.y" :x2="E.x" :y2="E.y" />
          <circle :cx="A.x" :cy="A.y" :r="A.r" fill="none" stroke="black" />
          <circle :cx="B.x" :cy="B.y" :r="B.r" fill="none" stroke="black" />
          <circle :cx="A.x" :cy="A.y" r="3" fill="black" />
          <circle :cx="B.x" :cy="B.y" r="3" fill="black" />
          <circle v-if="valid" :cx="C.x" :cy="C.y" r="3" fill="black" />
          <circle v-if="valid" :cx="D.x" :cy="D.y" r="3" fill="black" />
          <circle v-if="valid" :cx="E.x" :cy="E.y" r="3" fill="black" />
          <a-label :at="A" :opposite="B" label="A" />
          <a-label :at="B" :opposite="A" label="B" />
          <a-label v-if="valid" :at="C" :opposite="opposite_C" label="C" />
          <a-label v-if="valid" :at="theta_AC" :opposite="A" label="θ" />
          <a-label v-if="valid" :at="theta_AD" :opposite="A" label="θ" />
          <a-label v-if="valid" :at="D" :opposite="C" label="D" />
          <a-label v-if="valid" :at="E" :opposite="C" label="E" />
          <text x="300" y="275">
            <template v-if="containing">Larger circle contains smaller one</template>
            <template v-if="!overlapping">Circles don't overlap</template>
          </text>
        </svg>

        <p>
          Next, determine whether either of the intersection points fall between
          the start and end points of the hugging edge. If this is the case,
          then the obstacle blocks the hugging edge, and we should discard the
          edge.  Note that we don’t have to worry about the case where the
          hugging edge is entirely contained within an obstacle, as the line of
          sight culling for surfing edges will have already thrown the edge out.
        </p>

        <h3 id="nodes">Nodes</h3>

        <p>
          Other that the start and end points, the graph’s nodes are the
          endpoints of hugging edges.  Some hugging edges may share endpoints,
          and these can be coalesced into single nodes. This should happen only
          if the shared endpoint is on the same end of the hugging edge. The
          left endpoint of a hugging edge shouldn’t coalesce with the right
          endpoint of another hugging edge.
        </p>

        <h2 id="putting-it-all-together">Putting it all together</h2>

        <p>
          Given the generation of surfing and hugging edges, and the
          culling of blocked edges, we can produce a graph and run
          pathfinding using the A* algorithm.
        </p>

        <p>
          [Diagram: full demo]
        </p>

        <h2 id="enhancements">Enhancements</h2>

        <p>
          We could just eliminate this section for the first version.
        </p>

<h3>Allow obstacles to touch</h3>

<p>
Some bitangents won't exist.
</p>

<p>
Some hugging edges will be interrupted.
</p>

<h3>Variable actor radius via Minkowski expansion</h3>

        <p>
          When navigating a round object through a world of round obstacles, we
          can make a few observations that simplify the problem. First, we can
          make things easier by noticing that moving a circle of radius <em>r</em>
          through a forest of round obstacles is identical to moving a point
          through that same forest with one change: each obstacle has its radius
          increased by <em>r</em>. This is an extremely simple application of
          <em>Minkowski addition</em>, and it’s so effective for this case that from
          now on we’ll ignore the radius of the moving object. If it has a
          radius larger than zero, we’ll just increase the size of the obstacles
          before we start.
        </p>


        <h3 id="delayed-edge-generation">Delayed edge generation</h3>

        <p>
In general, the graph for a forest of \(n\) obstacles contains
\(O(n^2)\) surfing edges, but since each of these must be checked for
line of sight against \(n\) obstacles, the total time to generate the
graph is \(O(n^3)\). Additionally, pairs of surfing edges can induce
hugging edges, and each of these must be checked against every
obstacle for line of sight.  However, because the A* algorithm is so
efficient, it normally looks at only a fraction of this large graph to
produce an optimal path.

<p>
          [Diagram showing which graph edges were even looked at.]
</p>
<p>
We can save time by generating small portions of the graph on the fly
as we proceed through the A* algorithm, rather than doing all of the
work up front. If A* finds a path quickly, we'll generate only a small
part of the graph. We do this by moving edge generation to the
neighbors() function.
        </p>

<p>
There are several cases. At the beginning of the algorithm, we need the
neighbors of the start point. These are surfing edges from the start point
to the left and right edges of each obstacle.
</p>
<p>
The next case is when A* has just arrived at point \(p\) on on the
edge of obstacle \(C\) along a surfing edge. Neighbors() needs to
return the hugging edges leading from \(p\). To do this determine
which surfing edges leave the obstacle by computing the bitangents
between \(C\) and every other obstacle, throwing away any that do not
have line of sight. Then find all the hugging edges that connect \(p\)
to these surfing edges, discarding those that are blocked by other
obstacles. Return all of these hugging edges, saving the surfing edges
for return in a subsequent neighbors() call.
</p>
<p>
The last case is when A* has traversed a hugging edge along obstacle
\(C\) and needs to leave the \(C\) via a surfing edge. Because the
previous step calculated and saved all the surfing edges, the correct
set of edges can just be looked up and returned.
</p>

<h3>Store path tree in an array</h3>

Don't store each path separately; put them in a tree stored in an array.

        <h3 id="cull-longer-paths-to-same-place">Cull longer paths to same place</h3>

        <p>
          Before putting new paths into the priority queue, see if we’ve been to
          this spot going the same direction for a cheaper cost already.
        </p>




	<h3> Cull cusped hugging edges</h3>
        <p>

Hugging edges connect surfing edges which touch the same circle, but
it turns out that many of these hugging edges are not eligible to be
used in any optimal path. We can speed up the algorithm by eliminating
them.
</p>
<p>
An optimal path through the forest of obstacles always consists of
alternating surfing and hugging edges. A surfing edge arrives at an
obstacle on either its left or right side. In an optimal path, the
hugging edge <em>always continues along the same side of the
obstacle</em> until it reaches the surfing edge that it will exit the
obstacle along. Additionally, the exit surfing edge continues the same
direction of travel as the hugging edge. As the optimal path
alternates between surfing and hugging edges, there is no change of
direction at nodes.
</p>

<p>
[Static diagram illustrating continuous flow of the path]
</p>

<p>
We previously defined hugging edges as all the arcs which connect
endpoints of surfing edges on a given circle. But this simple
definition includes many hugging edges that represent direction
changes, or <em>cusps</em>. We want to avoid hugging edges like these:
</p>

<p>
[Static diagram showing bad hugging edges]
</p>

It's okay to put these hugging edges into the graph&mdash;A* will
never include them in the optimal path&mdash;but by keeping them out
of the graph, we make the algorithm more efficient.
</p>

<p>

To identify the cusped hugging edges, we can classify each surfing edge
touching a circle into one of two types: <em>left</em> edges
and <em>right</em> edges. Viewed from the endpoint which is not
touching the circle, left surfing edges intersect the left side of the
circle, while right edges touch the circle on the right side. Every
hugging edge connects a left surfing edge and a right surfing edge; if
one were to traverse the hugging edge from the left surfing edge to
the right surfing edge, travel around the circle would be clockwise.
        </p>

        <p>
          [Interactive diagram: three draggable circles with all bitangents
          drawn, with each bitangent endpoint drawn red or blue depending on
          whether they are left or right edges on that circle.]
        </p>

        <p>
With this distinction, we can find the set of non-cusped hugging edges
for a circle. First collect all the surfing edges which touch the
circle and classify them as left or right. Then for each left surfing
edge endpoint, generate a hugging edge to each right surfing edge
endpoint, traversing the circle clockwise. Because the graph is
undirected, each of these hugging edges also implies the existence of
another hugging edge which starts at a right edge, traverses around
the circle anticlockwise, and terminates on a left edge.
        </p>



        <h3 id="crossing-edge-culling">Crossing edge culling</h3>

        <p>
          Cull partial paths whose final surfing edge crosses the penultimate
          surfing edge.
        </p>

        <h3 id="polygonal-obstacles">Polygonal obstacles</h3>

        <p>
          exercise for the reader
        </p>

        <h3 id="spatial-index">Spatial index</h3>

        <h2 id="full-demo">Full demo</h2>

        <h2 id="references">References</h2>

        <ul>
          <li>Belt problem</li>
          <li>Pulley problem</li>
          <li>Point line distance</li>
          <li>Intersection of two circles</li>
        </ul>
        
      </div>
    </section>

    <footer>
      <svg width="0" height="0">
        <defs>
          <filter id="drop-shadow" x="-100%" y="-100%" width="300%" height="300%">
            <feGaussianBlur in="SourceAlpha" stdDeviation="2" />
            <feOffset dx="0" dy="1" result="offsetblur" />
            <feFlood flood-color="#000000" />
            <feComposite in2="offsetblur" operator="in" />
            <feMerge>
              <feMergeNode />
              <feMergeNode in="SourceGraphic" />
            </feMerge>
          </filter>
        </defs>
      </svg>

      <script>
        renderMathInElement(document.body);
      </script>
      <script src="https://unpkg.com/vue"></script>
      <script src="lib.js"></script>
      <script src="components.js"></script>
      <script src="belt-problem.js"></script>
      <script src="graph-diagrams.js"></script>
      
      <div>
        <p class="copyright">Copyright 2017 by <a href="https://github.com/redblobgames">redblobgames</a> and <a href="https://github.com/shillingsburg">shillingsburg</a>
        </p>
      </div>
    </footer>

  </body>
</html>
